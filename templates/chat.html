<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>AI Chat</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #f5f5f5;
      }
      #chat {
        width: 600px;
        height: 80vh;
        display: flex;
        flex-direction: column;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }
      #roles {
        padding: 10px;
        border-bottom: 1px solid #ddd;
        display: flex;
        gap: 10px;
      }
      #msgs {
        flex: 1;
        padding: 16px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .msg {
        max-width: 75%;
        padding: 10px;
        border-radius: 10px;
        white-space: pre-wrap;
        opacity: 0;
        animation: fadeIn 0.2s forwards;
      }
      .user {
        align-self: flex-end;
        background: #0078ff;
        color: #fff;
        border-bottom-right-radius: 0;
      }
      .assistant {
        align-self: flex-start;
        background: #e9ecef;
        color: #000;
        border-bottom-left-radius: 0;
      }
      #inputC {
        display: flex;
        border-top: 1px solid #ddd;
      }
      #txt {
        flex: 1;
        padding: 12px;
        border: none;
        outline: none;
        font-size: 16px;
      }
      button {
        padding: 0 20px;
        border: none;
        cursor: pointer;
        transition: 0.2s;
      }
      #send {
        background: #0078ff;
        color: #fff;
      }
      #send:hover {
        background: #005fcc;
      }
      #send:disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      #rec {
        background: #28a745;
        color: #fff;
      }
      #rec:hover {
        background: #1e7e34;
      }
      .rec {
        background: #ff4d4d !important;
      }
      .typing {
        font-style: italic;
        color: gray;
      }
      audio {
        margin-top: 5px;
        width: 100%;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="chat">
      <div id="roles">
        <label>角色:</label>
        <select id="roleSelect" style="flex: 1">
          {% for key, role in roles.items() %}
          <option value="{{ key }}">
            {{ role.name }} - {{ role.description }}
          </option>
          {% endfor %}
        </select>
      </div>
      <div id="msgs"></div>
      <div id="inputC">
        <input id="txt" placeholder="输入问题..." autocomplete="off" />
        <button id="rec"></button>
        <button id="send">发送</button>
      </div>
    </div>

    <script>
      let ws,
        currentMsg,
        mediaRecorder,
        chunks = [];
      const msgs = document.getElementById("msgs"),
        txt = document.getElementById("txt"),
        send = document.getElementById("send"),
        rec = document.getElementById("rec"),
        roleSelect = document.getElementById("roleSelect");

      function scrollBottom() {
        msgs.scrollTop = msgs.scrollHeight;
      }
      function addMsg(t, r) {
        const d = document.createElement("div");
        d.className = "msg " + r;
        d.textContent = t;
        msgs.appendChild(d);
        scrollBottom();
      }
      function b64ToBlob(b) {
        const u = atob(b),
          a = new Uint8Array(u.length);
        for (let i = 0; i < u.length; i++) a[i] = u.charCodeAt(i);
        return new Blob([a], { type: "audio/webm" });
      }
      function connect(role) {
        if (ws) ws.close();
        ws = new WebSocket("{{ ws_url }}?role=" + role);
        ws.onmessage = (e) => {
          let m = JSON.parse(e.data);
          if (m.type === "text") {
            if (!currentMsg) {
              currentMsg = document.createElement("div");
              currentMsg.className = "msg assistant";
              msgs.appendChild(currentMsg);
            }
            currentMsg.textContent += m.data;
            scrollBottom();
          } else if (m.type === "audio" && currentMsg) {
            let a = document.createElement("audio");
            a.controls = true;
            a.src = URL.createObjectURL(b64ToBlob(m.data));
            currentMsg.appendChild(a);
            scrollBottom();
          } else if (m.type === "eot") {
            unlock();
            currentMsg = null;
          }
        };
        ws.onclose = () => {
          unlock();
          currentMsg = null;
        };
      }
      function sendMsg(t) {
        if (!t) return;
        ws.send(JSON.stringify({ type: "text", data: t }));
        addMsg(t, "user");
        txt.value = "";
        txt.disabled = send.disabled = rec.disabled = true;
        currentMsg = null;
      }
      function toggleUI(r) {
        rec.textContent = r ? "⏹" : "";
        rec.classList.toggle("rec", r);
        txt.disabled = r;
        send.disabled = r;
      }
      function unlock() {
        toggleUI(false);
        rec.disabled = false;
      }
      send.onclick = () => sendMsg(txt.value.trim());
      txt.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          sendMsg(txt.value.trim());
        }
      });
      roleSelect.addEventListener("change", () => {
        connect(roleSelect.value);
        msgs.innerHTML = "";
      });
      connect(roleSelect.value);

      rec.onclick = async () => {
        if (mediaRecorder?.state === "recording") {
          mediaRecorder.stop();
          return;
        }
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          mediaRecorder = new MediaRecorder(stream);
          chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) chunks.push(e.data);
          };
          mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: mediaRecorder.mimeType });
            const fd = new FormData();
            fd.append("file", blob, "audio.webm");
            const asr = document.createElement("div");
            asr.className = "msg assistant typing";
            asr.textContent = "语音识别中...";
            msgs.appendChild(asr);
            scrollBottom();
            try {
              const res = await fetch("/asr", { method: "POST", body: fd });
              const r = await res.json();
              asr.remove();
              sendMsg(r.text || "[识别失败]");
            } catch (e) {
              asr.textContent = "[识别失败]";
              unlock();
            }
          };
          mediaRecorder.start();
          toggleUI(true);
        } catch (e) {
          alert("无法开始录音:" + e.message);
        }
      };
    </script>
  </body>
</html>
